# Документация по ассемблеру VCPU

## Архитектура процессора

### Регистры
- `R1-R6`: 8-битные регистры общего назначения (значения 0-255)
  - Могут использоваться для хранения:
    - Чисел
    - Координат
    - Временных значений
    - Адресов памяти
  - R4 часто используется как регистр остатка при делении

### Флаги
- `ZF` (flags[0x01]): Флаг нуля, устанавливается после операции CMP
  - 0: Числа равны
  - 1: Числа не равны

### Организация памяти
- 4 банка памяти по 256 байт каждый (всего 1024 байта)
- Каждый банк:
  - Адреса 0-127: Код программы
  - Адреса 128-243: Данные программы
  - Адреса 244-255: Стек (12 байт)
- Переключение между банками:
  - Инструкция BANK
  - При переходах между банками нужно явно указывать BANK перед JMP/JE/JNE

## Система ввода-вывода

### Пиксельный дисплей
- Разрешение: 16x16 пикселей
- Каждый пиксель:
  - Может быть включен/выключен
  - Имеет настраиваемую яркость (0-255)
- Координаты:
  - X: 0-15 (слева направо)
  - Y: 0-15 (сверху вниз)

### Семисегментный дисплей
- 8 разрядов
- Поддерживаемые символы:
  - Цифры: 0-9
  - Специальные символы:
    - Минус (код 10)
    - Подчеркивание (код 11)
    - Пробел (код 12)
    - E/ESC (код 13)
    - d/DEL (код 14)
    - n/ENTER (код 15)
    - Стрелки (коды 16-19)
- Режимы вывода:
  - Одиночный символ: указываем позицию (1-7) и значение
  - Полное число: позиция 0, число дополняется нулями слева

### Клавиатура
- Поддерживаемые клавиши и их коды:
  - Цифры: 0-9 (коды 0-9)
  - ESC: код 13
  - DEL: код 14
  - ENTER: код 15
  - Стрелки:
    - Вверх: код 16
    - Вниз: код 17
    - Вправо: код 18
    - Влево: код 19
- Два режима работы:
  - Активный опрос (GETKEY)
  - Автосохранение в память (SAVKEY)

## Инструкции

### Базовые операции
```asm
NOP           ; Нет операции
SET R1 42     ; R1 = 42
MOV R1 R2     ; R1 = R2
HLT           ; Остановка программы
```

### Арифметика
```asm
ADD R1 R2     ; R1 = R1 + R2
SUB R1 R2     ; R1 = R1 - R2
MUL R1 R2     ; R1 = R1 * R2
DIV R1 R2     ; R1 = R1 / R2, R4 = остаток
```

### Логические операции
```asm
AND R1 R2     ; R1 = R1 & R2
OR R1 R2      ; R1 = R1 | R2
XOR R1 R2     ; R1 = R1 ^ R2
CMP R1 R2     ; Сравнить R1 и R2 (устанавливает ZF)
```

### Работа с памятью
```asm
STOREV 0x80 42    ; MEM[0x80] = 42
STORER 0x80 R1    ; MEM[0x80] = R1
LOADR R1 0x80     ; R1 = MEM[0x80]
PUSH R1           ; Сохранить R1 в стек
POP R1            ; Достать значение из стека в R1
```

### Управление потоком
```asm
JMP LABEL         ; Безусловный переход
JE LABEL          ; Переход если равно (ZF = 0)
JNE LABEL         ; Переход если не равно (ZF = 1)
CALL FUNC         ; Вызов подпрограммы
RET               ; Возврат из подпрограммы
```

### Работа с дисплеем
```asm
SETPX R1 R2 R3    ; Установить пиксель (x,y) с яркостью
CLRPX R1 R2       ; Очистить пиксель (x,y)
DIGIT R1 R2       ; Вывести число на дисплей
BRIGHT R1         ; Установить общую яркость
CLEAR             ; Очистить все дисплеи
```

### Ввод и генерация случайных чисел
```asm
GETKEY R1         ; Получить код нажатой клавиши
SAVKEY 0x80       ; Автосохранение кодов в память
RND R1 15         ; Случайное число 0-15 в R1
```

### Работа с банками памяти
```asm
BANK 0            ; Переключиться на банк 0
BANK 1            ; Переключиться на банк 1
```

## Примеры программ

### 1. Мигающий пиксель
```asm
BANK 0
JMP START

:START
    CLEAR           ; Очистить экран
    SET R1 8        ; X = 8
    SET R2 8        ; Y = 8
    SET R3 255      ; Максимальная яркость

:LOOP
    SETPX R1 R2 R3  ; Включить пиксель
    CLRPX R1 R2     ; Выключить пиксель
    JMP LOOP        ; Повторять бесконечно
```

### 2. Счетчик нажатий
```asm
BANK 0
JMP START

:START
    SET R1 0        ; Позиция на дисплее
    SET R2 0        ; Счетчик
    STOREV 0x80 0   ; Сохраняем счетчик в память
    SAVKEY 0x81     ; Адрес для кодов клавиш

:LOOP
    LOADR R3 0x81   ; Загружаем код клавиши
    SET R4 15       ; Код ENTER
    CMP R3 R4       ; Сравниваем
    JNE SKIP        ; Если не ENTER, пропускаем

    LOADR R2 0x80   ; Загружаем счетчик
    SET R4 1
    ADD R2 R4       ; Увеличиваем
    STORER 0x80 R2  ; Сохраняем обратно
    DIGIT R1 R2     ; Выводим на дисплей

:SKIP
    STOREV 0x81 0   ; Очищаем код клавиши
    JMP LOOP
```

## Советы по программированию

### Организация кода
1. Используйте метки для структурирования кода
2. Разделяйте код на логические секции
3. Используйте комментарии для пояснений
4. Следите за банками памяти при переходах

### Отладка
1. Используйте вывод на сегментный дисплей для отладки
2. Проверяйте значения регистров
3. Следите за стеком при использовании CALL/RET
4. Проверяйте границы массивов и дисплея

### Оптимизация
1. Используйте регистры вместо памяти где возможно
2. Минимизируйте переключения между банками
3. Используйте SAVKEY вместо GETKEY для клавиатуры
4. Храните часто используемые значения в памяти

## Подробная работа с памятью

### Структура памяти
```
Банк 0 (0x000-0x0FF):          Банк 1 (0x100-0x1FF):
+------------------+           +------------------+
| Код программы    |           | Код программы    |
| 0x000-0x07F     |           | 0x100-0x17F     |
+------------------+           +------------------+
| Данные          |           | Данные           |
| 0x080-0x0F3     |           | 0x180-0x1F3     |
+------------------+           +------------------+
| Стек            |           | Стек             |
| 0x0F4-0x0FF     |           | 0x1F4-0x1FF     |
+------------------+           +------------------+

Банк 2 (0x200-0x2FF):          Банк 3 (0x300-0x3FF):
+------------------+           +------------------+
| Код программы    |           | Код программы    |
| 0x200-0x27F     |           | 0x300-0x37F     |
+------------------+           +------------------+
| Данные          |           | Данные           |
| 0x280-0x2F3     |           | 0x380-0x3F3     |
+------------------+           +------------------+
| Стек            |           | Стек             |
| 0x2F4-0x2FF     |           | 0x3F4-0x3FF     |
+------------------+           +------------------+
```

### Работа с банками памяти
- Каждый банк - независимая область памяти
- Переключение выполняется командой BANK
- При переходе между банками нужно явно указывать BANK перед JMP/JE/JNE
- Данные в разных банках не пересекаются

Пример работы с банками:
```asm
BANK 0              ; Переключаемся на банк 0
STOREV 0x80 42      ; Сохраняем 42 в банке 0 по адресу 0x80

BANK 1              ; Переключаемся на банк 1
STOREV 0x80 24      ; Сохраняем 24 в банке 1 по адресу 0x80
                    ; Значение в банке 0 не изменилось!

; Состояние памяти:
; Банк 0: [0x80] = 42
; Банк 1: [0x80] = 24
```

### Команды работы с памятью

#### STOREV - Сохранение значения
```asm
STOREV 0x80 42      ; Сохраняет число 42 по адресу 0x80

; Память до:    [0x80] = 00
; Память после: [0x80] = 2A (42 в hex)
```

#### STORER - Сохранение из регистра
```asm
SET R1 42           ; R1 = 42
STORER 0x80 R1      ; Сохраняет значение R1 по адресу 0x80

; Память до:    [0x80] = 00
; Память после: [0x80] = 2A (42 в hex)
```

#### LOADR - Загрузка в регистр
```asm
STOREV 0x80 42      ; Записываем 42 в память
LOADR R1 0x80       ; Загружаем значение в R1

; Память:     [0x80] = 2A
; До:         R1 = 00
; После:      R1 = 2A (42 в dec)
```

### Работа со стеком
Стек растет сверху вниз (от больших адресов к меньшим)
```
Начальное состояние стека (банк 0):
0x0FF: 00  <- Вершина стека
0x0FE: 00
0x0FD: 00
...
0x0F4: 00

После PUSH R1 (R1 = 42):
0x0FF: 2A  <- Значение из R1
0x0FE: 00  <- Новая вершина
0x0FD: 00
...
0x0F4: 00

После POP R2:
0x0FF: 2A  
0x0FE: 00  <- Вершина стека
0x0FD: 00
...
0x0F4: 00
R2 = 42    <- Значение помещено в R2
```

## Управление потоком выполнения

### Метки
- Метки начинаются с двоеточия
- Используются для обозначения точек перехода
- При компиляции заменяются на адреса
```asm
:LOOP           ; Метка LOOP
    SET R1 1    ; Какой-то код
    JMP LOOP    ; Переход на метку LOOP
```

### Вызов подпрограмм
CALL сохраняет адрес возврата в стек и переходит по метке:
```asm
            ; Стек пуст
CALL FUNC   ; Сохраняет адрес следующей инструкции
            ; и переходит на FUNC
            ; Стек: [адрес возврата]

:FUNC
    SET R1 42   ; Код подпрограммы
    RET         ; Достает адрес из стека и переходит туда
                ; Стек снова пуст
```

### Пример вложенных вызовов
```asm
BANK 0
JMP START

:START
    SET R1 1        ; R1 = 1
    CALL FUNC_A     ; Вызываем FUNC_A
    HLT            ; Конец программы

:FUNC_A
    SET R2 2        ; R2 = 2
    CALL FUNC_B     ; Вызываем FUNC_B
    RET             ; Возврат в START

:FUNC_B
    SET R3 3        ; R3 = 3
    RET             ; Возврат в FUNC_A

; Состояние стека при выполнении:
; 1. После CALL FUNC_A:
;    0x0FF: [адрес после CALL FUNC_A]
;
; 2. После CALL FUNC_B в FUNC_A:
;    0x0FF: [адрес после CALL FUNC_A]
;    0x0FE: [адрес после CALL FUNC_B]
;
; 3. После первого RET (в FUNC_B):
;    0x0FF: [адрес после CALL FUNC_A]
;
; 4. После второго RET (в FUNC_A):
;    Стек пуст
```

### Советы по работе с памятью
1. Используйте начало области данных (0x80-0x8F) для глобальных переменных
2. Храните временные данные в регистрах
3. Используйте стек для сохранения регистров в подпрограммах
4. Документируйте назначение каждой используемой ячейки памяти

### Пример работы с массивом в памяти
```asm
; Сохранение массива из 5 чисел
SET R1 0x80        ; Начальный адрес
SET R2 1           ; Первое число
SET R3 5           ; Размер массива

:WRITE_LOOP
    STORER R1 R2   ; Сохраняем число
    ADD R1 1       ; Следующий адрес
    ADD R2 1       ; Следующее число
    SUB R3 1       ; Уменьшаем счетчик
    JNE WRITE_LOOP ; Повторяем если не конец

; Результат в памяти:
; 0x80: 01
; 0x81: 02
; 0x82: 03
; 0x83: 04
; 0x84: 05
```